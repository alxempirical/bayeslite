from __future__ import division
from collections import namedtuple as nt
import numpy as np
from numpy.random import RandomState

from reals import isintegral
from Multinomial import Multinomial


def check_variable(v):
    try:
        v.lpdf(v.sample(RandomState(0), n=1))
    except:
        raise ValueError('Lacks functional `sample` or `lpdf` method')

class IndependentVariables(nt('IndependentVariables', 'variables')):

    'n independent variables, which must provide `lpdf` and `sample` methods'

    def __init__(self, variables):
        for v in variables:
            check_variable(v)

    def sample(self, prngstate, n):
        return np.vstack([v.sample(prngstate, n) for v in self.variables]).T

    def lpdf(self, x):
        return sum(v.lpdf(x) for v in self.variables)


class MixtureSample(nt('MixtureSample', 'mixture assignments values')):

    """List of assignments of rows to components of the mixture, as int indexes,
    and the samples drawn from those components

    """

    def __init__(self, mixture, assignments, values):
        if len(assignments) != len(values):
            raise ValueError('should be a component assignment for each value')
        aloc = 0 <= min(assignments) <= max(assignments) < len(mixture.weights.weights)
        if (not aloc) or (not all(isintegral(a) for a in assignments)):
            raise ValueError('assignments should be the components values '
                             'were sampled from, as indices')
        # If the values are not in the domain of their specified components,
        # this will fail.
        [mixture.components[i].lpdf(v) for i, v in zip(assignments, values)]


class Mixture(nt('Mixture', 'weights components')):

    """Mixture of distributions in `components`, weighted by `weights`.
    `components` must provide `lpdf` and `sample` methods"""

    def __init__(self, weights, components):
        for c in components:
            check_variable(c)
        if not isinstance(weights, Multinomial):
            raise ValueError('weights must be a multinomial')
        r = RandomState(0)
        samples = [c.sample(r, n=1) for c in components]
        if len(set(type(s) for s in samples)) != 1:
            raise ValueError("Components don't generate values of same type")
        if isinstance(samples[0], np.ndarray):
            if len(set(s.shape for s in samples)) != 1:
                raise ValueError("Different shapes generated by components")

    def sample(self, prngstate, n=1):
        components = self.weights.sample(prngstate, n)
        values = np.vstack([self.components[c].sample(prngstate, n)
                            for c in components])
        return MixtureSample(self, components, values)

    def lpdf(self, x):
        lpdfs = np.array([c.lpdf(x) for c in self.components])
        return self.mixture.logmean(lpdfs)
